# -*- coding: utf-8 -*-
"""pySpark_apriori.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1YLJGkQBo1qvycGPWtSk_EaCKpwBhED1Y

# **Project: Apriori Algorithm for Finding Frequent Itemsets with PySpark**

## Task 1: Import the Libraries and Set Up the Environment
"""

import itertools
import findspark
findspark.init()
import pyspark
from pyspark.sql import *

conf = pyspark.SparkConf().setAppName('Apriori').setMaster('local')
sc = pyspark.SparkContext(conf=conf)
spark = SparkSession(sc)
# spark

"""# Task 2: Generate Combinations—Parent Intersection Property"""

def pre_check(freq_k_1, k):
    k_size_comb = []
    for i in range(len(freq_k_1)):
        x = set(freq_k_1[i])
        for j in range(len(freq_k_1)):
            y = set(freq_k_1[j])
            if j<i:
                if len(x.intersection(y)) >= (k-2):
                    k_size_comb.append(tuple(sorted(list(x.union(y)))))
    return k_size_comb

"""## Task 3: Generate Combinations—Subset Frequency Property"""

def post_check(k_size_comb, freq_k_1, k):
    filtered = []
    for  comb in  k_size_comb:
        flag = False
        for sub_comb in itertools.combinations(comb, k-1):
            if sub_comb not in freq_k_1:
                flag = True
        if flag == False:
            filtered.append(tuple(comb))
    return filtered

"""## Task 4: Count Check"""

def count_check(filtered, lines, supCount):
    results = []
    counts = dict(zip(filtered, [0]*len(filtered)))
    for combination in filtered:
        present = [False]*len(combination)
        for i in range(len(combination)):
            for line in lines:
                if combination[i] in line:
                    present[i] = True
                if all(present):
                    counts[combination] +=1

    for word, count in counts.items():
        if (count>=supCount):
            results.append(word)
    return results

"""## Task 5: Generate k-Size Combinations"""

def generator(freq_k_1, k, partition, support):

    lines = list(partition)
    supCount = len(lines)*support

    k_size_comb = pre_check(freq_k_1, k)

    filtered = post_check(k_size_comb, freq_k_1, k)

    return count_check(filtered, lines, supCount)

"""## Task 6: Generate Singles"""

def get_singles(lines, support):
    supCount = len(list(lines))*support
    vocab = set([])
    for line in lines:
        for word in line:
            vocab.add(word)
    counts = dict(zip(vocab, [0]*len(list(vocab))))
    combinations = []
    for line in lines:
        for word in line:
            counts[word] +=1
    for word, count in counts.items():
        if (count>=supCount):
            combinations.append(tuple((word,)))
    return sorted(combinations)

"""## Task 7: The Worker Partition Mapper"""

seq_len = sc.broadcast(2)

def apriori(iterator):
    partition = []
    for v in iterator:
        partition.append(v)
    support = sup.value
    results= get_singles(partition, support)
    print('starting with', results)

    for k in range(2, seq_len.value+1):
        print('sequence length', k)

        combos = generator(results, k, partition, support)

        if len(combos) == 0:
            print('ending at sequence length' ,k-1)
            return results

        results = combos
    return results

"""## Task 8: Load Data and Preprocess"""

rdd = sc.textFile("usercode/Dataset.csv")
tagsheader = rdd.first()
tags = sc.parallelize(tagsheader)
seq_len = sc.broadcast(3)
data = rdd.subtract(tags)
length = sc.broadcast(data.count())
sup = sc.broadcast(0.03)
lines = data.map(lambda x: x.lstrip('"').rstrip('"').split(','))

"""## Task 9: The Distributed Transform"""

freq = lines.mapPartitions(apriori)
freq = freq.distinct()
comb = freq.collect()
print("Possible frequent itemset(s):\n", comb)

"""## Task 10: Auxiliary Function to Check Presence"""

def auxiliary(row, combinations):
    present= []
    for combination in combinations:
        presence = [False]*len(combination)
        for i in range(len(combination)):
            presence[i] = combination[i] in row
        if all(presence):
            present+=[combination]
    return present

"""## Task 11: Count Check at Master"""

comb = sc.broadcast(comb)
freq1 = lines.map(lambda x: [(key, 1) for key in auxiliary(x, comb.value)]).filter(lambda x: len(x)>0)

freq2 = freq1.flatMap(lambda x: x)
freq3 = freq2.reduceByKey(lambda x, y: x+y)
freq4 = freq3.filter(lambda x: x[1]>sup.value*length.value).map(lambda x: x[0])
freq4.collect()

"""# End"""